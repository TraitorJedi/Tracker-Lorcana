<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lorcana Match Reporter</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      }
      body {
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #1f2937, #0f172a);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #f8fafc;
      }
      main {
        width: min(900px, 95vw);
        display: grid;
        gap: 2rem;
        padding: 2.5rem;
        background: rgba(15, 23, 42, 0.85);
        border-radius: 20px;
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.6);
        backdrop-filter: blur(12px);
      }
      header h1 {
        margin: 0;
        font-size: clamp(2rem, 3vw + 1rem, 3rem);
        color: #fde68a;
      }
      header p {
        margin: 0.5rem 0 0;
        color: rgba(248, 250, 252, 0.85);
      }
      section {
        background: rgba(30, 41, 59, 0.8);
        border-radius: 16px;
        padding: 1.75rem;
        display: grid;
        gap: 1.5rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }
      section h2 {
        margin: 0;
        font-size: 1.5rem;
        color: #fbbf24;
      }
      form {
        display: grid;
        gap: 1.25rem;
      }
      label {
        display: grid;
        gap: 0.4rem;
        font-weight: 600;
        color: #f8fafc;
      }
      input,
      select,
      button {
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        padding: 0.75rem 1rem;
        font-size: 1rem;
        font-family: inherit;
        background: rgba(15, 23, 42, 0.85);
        color: inherit;
        transition: border 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
      }
      input:focus,
      select:focus {
        outline: none;
        border-color: #fbbf24;
        box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.25);
      }
      button {
        cursor: pointer;
        font-weight: 700;
        background: linear-gradient(135deg, #f59e0b, #f97316);
        border: none;
        color: #0f172a;
        box-shadow: 0 12px 25px rgba(249, 115, 22, 0.35);
      }
      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 16px 30px rgba(249, 115, 22, 0.45);
      }
      .inline {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      .inline input {
        flex: 1;
        min-width: 200px;
      }
      .deck-grid {
        display: grid;
        gap: 0.75rem;
      }
      .deck-icons {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
      }
      .deck-plus {
        color: rgba(248, 250, 252, 0.7);
        font-weight: 700;
      }
      .deck-selection {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-weight: 600;
        color: rgba(248, 250, 252, 0.8);
      }
      .deck-text {
        font-size: 0.95rem;
        color: rgba(248, 250, 252, 0.8);
      }
      .ink-icon {
        width: 42px;
        height: 42px;
        display: block;
        object-fit: contain;
        filter: drop-shadow(0 2px 6px rgba(15, 23, 42, 0.6));
      }
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }
      .message {
        padding: 0.75rem 1rem;
        border-radius: 10px;
        font-weight: 600;
      }
      .message.success {
        background: rgba(34, 197, 94, 0.15);
        color: #bbf7d0;
        border: 1px solid rgba(34, 197, 94, 0.4);
      }
      .message.error {
        background: rgba(239, 68, 68, 0.15);
        color: #fecaca;
        border: 1px solid rgba(239, 68, 68, 0.4);
      }
      .hidden {
        display: none;
      }
      .result-card {
        background: rgba(15, 23, 42, 0.85);
        border-radius: 12px;
        padding: 1rem 1.25rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        display: grid;
        gap: 0.5rem;
      }
      .result-card strong {
        color: #fbbf24;
      }
      .summary-section {
        display: grid;
        gap: 1.25rem;
      }
      .summary-grid {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        align-items: start;
      }
      .summary-card {
        background: rgba(15, 23, 42, 0.85);
        border-radius: 12px;
        padding: 1rem 1.25rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }
      .summary-total {
        font-size: 1.5rem;
        font-weight: 700;
        color: #fbbf24;
        margin: 0;
      }
      .summary-list {
        display: grid;
        gap: 0.75rem;
        margin: 0;
        padding: 0;
        list-style: none;
      }
      .summary-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
      }
      .summary-label {
        display: grid;
        gap: 0.35rem;
      }
      .summary-count {
        font-weight: 600;
        color: rgba(248, 250, 252, 0.75);
      }
      .summary-chart {
        width: 100%;
        max-width: 320px;
        aspect-ratio: 1 / 1;
        margin: 0 auto;
      }
      @media (max-width: 640px) {
        main {
          padding: 1.75rem;
        }
        section {
          padding: 1.25rem;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header>
        <h1>Lorcana Match Reporter</h1>
        <p>Select the event, then record color choices or look up your next opponent.</p>
      </header>

      <section>
        <h2>Select Event</h2>
        <form id="event-form">
          <label>
            Event
            <select id="event-select" name="event" required>
              <option value="" disabled selected>Select an event</option>
            </select>
          </label>
        </form>
        <div id="event-message" role="status"></div>
      </section>

      <section>
        <h2>Report a Matchup</h2>
        <form id="report-form" class="hidden">
          <label>
            Player name
            <input
              id="player-input"
              name="player"
              list="player-names"
              placeholder="Select a player from the list"
              autocomplete="off"
              required
            />
            <datalist id="player-names"></datalist>
          </label>

          <label>
            Ink color 1
            <select id="ink-select-1" name="ink1" required>
              <option value="" disabled selected>Select ink color 1</option>
            </select>
          </label>

          <label>
            Ink color 2
            <select id="ink-select-2" name="ink2" required>
              <option value="" disabled selected>Select ink color 2</option>
            </select>
            <input id="deck-input" name="deck" type="hidden" required />
            <div id="deck-selection" class="deck-selection" aria-live="polite"></div>
          </label>

          <button type="submit">Submit matchup</button>
        </form>
        <div id="confirmation-card" class="result-card hidden"></div>
        <div id="report-message" role="status"></div>
      </section>

      <section>
        <h2>Lookup a Player</h2>
        <form id="lookup-form" class="inline hidden">
          <input
            id="lookup-input"
            name="lookup"
            list="player-names"
            placeholder="Select a player from the list"
            autocomplete="off"
            required
          />
          <button type="submit">Search</button>
        </form>
        <div id="lookup-result" role="status"></div>
      </section>

      <section id="summary-section" class="hidden">
        <h2>Event Summary</h2>
        <div class="summary-section">
          <div class="summary-grid">
            <div class="summary-card">
              <p class="summary-total" id="summary-total">Total submitted decks: 0</p>
              <ul class="summary-list" id="summary-list"></ul>
            </div>
            <div class="summary-card">
              <canvas id="summary-chart" class="summary-chart" aria-label="Deck distribution pie chart" role="img"></canvas>
            </div>
          </div>
          <div id="summary-message" role="status"></div>
        </div>
      </section>
    </main>

    <script>
      const eventSelect = document.getElementById('event-select');
      const eventMessage = document.getElementById('event-message');
      const playerDatalist = document.getElementById('player-names');
      const inkSelect1 = document.getElementById('ink-select-1');
      const inkSelect2 = document.getElementById('ink-select-2');
      const deckInput = document.getElementById('deck-input');
      const deckSelection = document.getElementById('deck-selection');
      const reportForm = document.getElementById('report-form');
      const reportMessage = document.getElementById('report-message');
      const confirmationCard = document.getElementById('confirmation-card');
      const lookupForm = document.getElementById('lookup-form');
      const lookupResult = document.getElementById('lookup-result');
      const summarySection = document.getElementById('summary-section');
      const summaryTotal = document.getElementById('summary-total');
      const summaryList = document.getElementById('summary-list');
      const summaryChart = document.getElementById('summary-chart');
      const summaryMessage = document.getElementById('summary-message');
      const playerMap = new Map();
      let activeEvent = null;
      let inkColor1 = '';
      let inkColor2 = '';

      const INK_ORDER = ['Amber', 'Amethyst', 'Emerald', 'Ruby', 'Sapphire', 'Steel'];
      const INK_SYMBOLS = {
        Amber: '/ink/amber.png',
        Amethyst: '/ink/amethyst.png',
        Emerald: '/ink/emerald.png',
        Ruby: '/ink/ruby.png',
        Sapphire: '/ink/sapphire.png',
        Steel: '/ink/steel.png'
      };

      function renderInkIcon(color) {
        const src = INK_SYMBOLS[color] || '';
        return `
          <img class="ink-icon" src="${src}" alt="${color} ink" />
        `;
      }

      function normalizeDeckName(colorA, colorB) {
        const colors = [colorA, colorB].filter(Boolean);
        if (colors.length !== 2) return '';
        colors.sort((a, b) => INK_ORDER.indexOf(a) - INK_ORDER.indexOf(b));
        return colors.join('/');
      }

      function renderDeckIcons(deckName, showText = false) {
        if (!deckName) return '';
        const colors = deckName.split('/').map((c) => c.trim());
        const icons = colors.map((color) => renderInkIcon(color)).join('<span class="deck-plus">+</span>');
        const label = showText ? `<span class="deck-text">${deckName}</span>` : `<span class="sr-only">${deckName}</span>`;
        return `<div class="deck-icons">${icons}</div>${label}`;
      }

      function clearDeckSelection() {
        deckInput.value = '';
        deckSelection.innerHTML = '';
        inkColor1 = '';
        inkColor2 = '';
        inkSelect1.selectedIndex = 0;
        inkSelect2.selectedIndex = 0;
      }

      function setMessage(element, message, type) {
        element.textContent = message || '';
        element.className = type ? `message ${type}` : 'message';
      }

      function clearMessage(element) {
        element.textContent = '';
        element.className = '';
      }

      function setEventLocked(isLocked) {
        reportForm.classList.toggle('hidden', isLocked);
        lookupForm.classList.toggle('hidden', isLocked);
        summarySection.classList.toggle('hidden', isLocked);
        confirmationCard.classList.add('hidden');
        if (isLocked) {
          reportForm.reset();
          lookupForm.reset();
          clearDeckSelection();
          summaryList.replaceChildren();
          summaryTotal.textContent = 'Total submitted decks: 0';
          clearMessage(summaryMessage);
          drawSummaryChart([]);
        }
      }

      async function loadEvents() {
        try {
          const response = await fetch('/events');
          if (!response.ok) throw new Error('Unable to load events');
          const events = await response.json();
          eventSelect.replaceChildren(
            new Option('Select an event', '', true, true),
            ...events.map((event) => new Option(event.name, event.id))
          );
          if (!events.length) {
            setMessage(eventMessage, 'No events found. Ask an admin to create one.', 'error');
          }
        } catch (error) {
          console.error(error);
          setMessage(eventMessage, error.message, 'error');
        }
      }

      async function loadPlayers(startsWith = '') {
        try {
          const query = startsWith ? `?startsWith=${encodeURIComponent(startsWith)}` : '';
          const response = await fetch(`/players${query}`);
          if (!response.ok) throw new Error('Unable to load players');
          const players = await response.json();
          playerMap.clear();
          players.forEach((name) => playerMap.set(name.toLowerCase(), name));
          playerDatalist.replaceChildren(
            ...players.map((name) => {
              const option = document.createElement('option');
              option.value = name;
              return option;
            })
          );
        } catch (error) {
          console.error(error);
        }
      }

      function updateDeckSelection() {
        const deckName = normalizeDeckName(inkColor1, inkColor2);
        deckInput.value = deckName;
        if (deckName) {
          deckSelection.innerHTML = renderDeckIcons(deckName, true);
        } else {
          deckSelection.innerHTML = '';
        }
      }

      function renderInkOptions(select) {
        select.replaceChildren(
          new Option(select.options[0].textContent, '', true, true),
          ...INK_ORDER.map((color) => new Option(color, color))
        );
      }

      function getChartColors(count) {
        const palette = ['#f59e0b', '#22c55e', '#3b82f6', '#a855f7', '#f43f5e', '#14b8a6', '#eab308'];
        return Array.from({ length: count }, (_, index) => palette[index % palette.length]);
      }

      function drawSummaryChart(data) {
        const ctx = summaryChart.getContext('2d');
        const size = summaryChart.clientWidth || 240;
        const scale = window.devicePixelRatio || 1;
        summaryChart.width = size * scale;
        summaryChart.height = size * scale;
        ctx.scale(scale, scale);
        ctx.clearRect(0, 0, size, size);

        if (!data.length) {
          ctx.fillStyle = 'rgba(248, 250, 252, 0.45)';
          ctx.font = '600 14px system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('No data yet', size / 2, size / 2);
          return;
        }

        const total = data.reduce((sum, item) => sum + item.count, 0);
        let startAngle = -Math.PI / 2;
        const colors = getChartColors(data.length);
        data.forEach((item, index) => {
          const slice = (item.count / total) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(size / 2, size / 2);
          ctx.arc(size / 2, size / 2, size / 2 - 6, startAngle, startAngle + slice);
          ctx.closePath();
          ctx.fillStyle = colors[index];
          ctx.fill();
          startAngle += slice;
        });
      }

      function renderSummary(summary) {
        summaryList.replaceChildren();
        clearMessage(summaryMessage);

        const total = summary.total || 0;
        summaryTotal.textContent = `Total submitted decks: ${total}`;

        if (!summary.decks.length) {
          setMessage(summaryMessage, 'No deck submissions yet for this event.', 'error');
          drawSummaryChart([]);
          return;
        }

        summary.decks.forEach((deck) => {
          const percent = total ? Math.round((deck.count / total) * 100) : 0;
          const row = document.createElement('li');
          row.className = 'summary-row';
          row.innerHTML = `
            <div class="summary-label">
              ${renderDeckIcons(deck.name, true)}
              <span class="summary-count">${deck.count} submissions â€¢ ${percent}%</span>
            </div>
          `;
          summaryList.appendChild(row);
        });
        drawSummaryChart(summary.decks);
      }

      async function loadSummary(eventId) {
        if (!eventId) return;
        try {
          const response = await fetch(`/events/${eventId}/summary`);
          if (!response.ok) throw new Error('Unable to load event summary');
          const payload = await response.json();
          renderSummary(payload);
        } catch (error) {
          console.error(error);
          setMessage(summaryMessage, error.message, 'error');
          drawSummaryChart([]);
        }
      }

      eventSelect.addEventListener('change', () => {
        const selectedId = eventSelect.value;
        if (!selectedId) {
          activeEvent = null;
          setEventLocked(true);
          return;
        }
        activeEvent = { id: selectedId, name: eventSelect.options[eventSelect.selectedIndex].text };
        clearMessage(eventMessage);
        setEventLocked(false);
        loadSummary(activeEvent.id);
      });

      reportForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        clearMessage(reportMessage);
        confirmationCard.classList.add('hidden');

        const formData = new FormData(reportForm);
        const player = formData.get('player')?.trim();
        const deck = deckInput.value;

        if (!activeEvent) {
          setMessage(reportMessage, 'Select an event first.', 'error');
          return;
        }

        if (!player || !deck) {
          setMessage(reportMessage, 'Player and deck are required.', 'error');
          return;
        }
        if (inkColor1 === inkColor2) {
          setMessage(reportMessage, 'Choose two different ink colors.', 'error');
          return;
        }

        const matchedPlayer = playerMap.get(player.toLowerCase());
        const selectedPlayer = matchedPlayer || player;

        try {
          const response = await fetch('/submit', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ event_id: activeEvent.id, player: selectedPlayer, deck })
          });

          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || 'Unable to record matchup');
          }

          setMessage(reportMessage, payload.message || 'Matchup recorded!', 'success');
          confirmationCard.innerHTML = `
            <div><strong>Event:</strong> ${activeEvent.name}</div>
            <div><strong>Player:</strong> ${selectedPlayer}</div>
            <div><strong>Deck:</strong> ${renderDeckIcons(deck, true)}</div>
            <div><strong>Status:</strong> Entry saved. Review the details above.</div>
          `;
          confirmationCard.classList.remove('hidden');
          reportForm.reset();
          clearDeckSelection();
          await loadPlayers();
          await loadSummary(activeEvent.id);
        } catch (error) {
          console.error(error);
          setMessage(reportMessage, error.message, 'error');
        }
      });

      lookupForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        clearMessage(lookupResult);

        const formData = new FormData(lookupForm);
        const player = formData.get('lookup')?.trim();
        if (!activeEvent) {
          setMessage(lookupResult, 'Select an event first.', 'error');
          return;
        }
        if (!player) {
          setMessage(lookupResult, 'Enter a player name to search.', 'error');
          return;
        }

        const lookupName = playerMap.get(player.toLowerCase()) || player;

        try {
          const response = await fetch(
            `/lookup?event=${encodeURIComponent(activeEvent.id)}&player=${encodeURIComponent(lookupName)}`
          );
          if (response.status === 404) {
            setMessage(lookupResult, 'No matchup found for this player yet.', 'error');
            return;
          }
          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || 'Unable to lookup player');
          }

          const card = document.createElement('div');
          card.className = 'result-card';
          card.innerHTML = `
            <div><strong>Event:</strong> ${activeEvent.name}</div>
            <div><strong>Player:</strong> ${payload.player || lookupName}</div>
            <div><strong>Deck:</strong> ${payload.deck ? renderDeckIcons(payload.deck, true) : 'Unknown'}</div>
            ${payload.created_at ? `<div><strong>Reported:</strong> ${new Date(payload.created_at).toLocaleString()}</div>` : ''}
          `;
          lookupResult.replaceChildren(card);
        } catch (error) {
          console.error(error);
          setMessage(lookupResult, error.message, 'error');
        }
      });

      setEventLocked(true);
      loadEvents();
      playerDatalist.replaceChildren();
      const playerInput = document.getElementById('player-input');
      const lookupInput = document.getElementById('lookup-input');

      async function handlePlayerAutocomplete(value) {
        const trimmed = value.trim();
        if (!trimmed) {
          playerMap.clear();
          playerDatalist.replaceChildren();
          return;
        }
        await loadPlayers(trimmed[0]);
      }

      playerInput.addEventListener('input', (event) => {
        handlePlayerAutocomplete(event.target.value);
      });

      lookupInput.addEventListener('input', (event) => {
        handlePlayerAutocomplete(event.target.value);
      });
      renderInkOptions(inkSelect1);
      renderInkOptions(inkSelect2);
      inkSelect1.addEventListener('change', () => {
        inkColor1 = inkSelect1.value;
        updateDeckSelection();
      });
      inkSelect2.addEventListener('change', () => {
        inkColor2 = inkSelect2.value;
        updateDeckSelection();
      });
    </script>
  </body>
</html>
